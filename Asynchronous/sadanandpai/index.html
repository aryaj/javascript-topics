<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //=============== Question =====================//

        // Execute an array of asynchronous functions one after the other in sequence using callbacks
        // https://jscodechallenges.vercel.app/challenges/async#7-execute-an-array-of-asynchronous-functions-one-after-the-other-in-sequence-using-callbacks


        /* function async1(callback) {
            setTimeout(() => {
                console.log('Async 1 completed')
                callback()
            }, 1000);
        }
        function async2(callback) {
            setTimeout(() => {
                console.log('Async 2 completed')
                callback()
            }, 2000);
        }
        function async3(callback) {
            setTimeout(() => {
                console.log('Async 3 completed')
                callback()
            }, 3000);
        }

        function callbackManager(callbacks) {
            function nextAsyncExecuter() {
                const nextAsyncFunc = callbacks.shift();
                if (nextAsyncFunc && typeof nextAsyncFunc === "function") {
                    nextAsyncFunc(nextAsyncExecuter)
                }
            }
            nextAsyncExecuter()
        }

        callbackManager([async1, async2, async3]); */




        //=============== Question =====================//

        // Execute the given list of asynchronous functions in parallel and return the results as an array to the callback

        // https://jscodechallenges.vercel.app/challenges/async#8-execute-the-given-list-of-asynchronous-functions-in-parallel-and-return-the-results-as-an-array-to-the-callback


        /* function asyncFunction1(callback) {
            setTimeout(() => {
                callback(1)
            }, 1000)
        }
        function asyncFunction2(callback) {
            setTimeout(() => {
                callback(2)
            }, 2000)
        }
        function asyncFunction3(callback) {
            setTimeout(() => {
                callback(3)
            }, 3000)
        }

        const tasks = [asyncFunction1, asyncFunction2, asyncFunction3];

        function resultCallback(completedResult) {
            console.log("completedResult", completedResult);
        }

        function asyncParallel(tasks, resultCallback) {
            let result = [];

            tasks.forEach((element, index) => {
                element(val => {
                    result.push(val);
                    if (tasks.length === result.length) {
                        resultCallback(result);
                    }
                });

            });

        }

        asyncParallel(tasks, resultCallback) */


        //=============== Question =====================//

        // Execute 3 asynchronous functions one after the other in sequence using promise chaining and do not terminate on failure

        // https://jscodechallenges.vercel.app/challenges/async#11-execute-3-asynchronous-functions-one-after-the-other-in-sequence-using-promise-chaining-and-do-not-terminate-on-failure

        /* const ayncFunc1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('Async 1 Resolved')
            }, 1000)
        })
        const ayncFunc2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject('Async 2 Failed')
            }, 1000)
        })
        const ayncFunc3 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('Async 1 Resolved')
            }, 1000)
        });

        ayncFunc1.then((val) => {
            console.log(val)
        }, (val) => {
            console.log(val)
        }).then(() => {
            return ayncFunc2
        }).then((val) => {
            console.log(val)
        }, (val) => {
            console.log(val)
        }).then(() => {
            return ayncFunc3
        }).then((val) => {
            console.log(val)
        }, (val) => {
            console.log(val)
        }).catch(err => console.log(err)) */

        //=============== Question =====================//

        // Execute 3 asynchronous functions one after the other in sequence using async await and do not terminate on failure

        // https://jscodechallenges.vercel.app/challenges/async#12-execute-3-asynchronous-functions-one-after-the-other-in-sequence-using-async-await-and-do-not-terminate-on-failure


        /* const asyncFunc1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('Async 1 Resolved')
            }, 1000)
        })
        const asyncFunc2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject('Async 2 Failed')
            }, 1000)
        })
        const asyncFunc3 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('Async 1 Resolved')
            }, 1000)
        });

        (async function executer() {
            try {
                await asyncFunc1;
                console.log('Async1 success')
            }
            catch (err) {
                console.log(err)
            }
            try {
                await asyncFunc2;
                console.log('Async1 success')
            }
            catch (err) {
                console.log(err)
            }
            try {
                await asyncFunc3;
                console.log('Async1 success')
            }
            catch (err) {
                console.log(err)
            }
        })() */

        //=============== Question =====================//

        // Execute an array of asynchronous functions simultaneously but print the output in the ordered sequence. Do not wait for printing the data if it already available after promise is settled

        // https://jscodechallenges.vercel.app/challenges/async#14-execute-an-array-of-asynchronous-functions-simultaneously-but-print-the-output-in-the-ordered-sequence-do-not-wait-for-printing-the-data-if-it-already-available-after-promise-is-settled

        /*  const asyncFunc1 = () => {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('Async 1 Resolved')
                }, 1000)
            })
        }
        const asyncFunc2 = () => {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject('Async 2 Failed')
                }, 2000)
            })
        }
        const asyncFunc3 = () => {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('Async 3 Resolved')
                }, 3000)
            });
        }

        const asyncFuncArr = [asyncFunc1, asyncFunc2, asyncFunc3];

        const result = asyncFuncArr.map((asycFunc) => asycFunc());

         result.reduce((acc, promise) => {
             return acc.then(() => {
                 return promise
             }).then((val) => console.log(val)).catch(err => {
                 console.log(err);
             })
         }, Promise.resolve()) */

        // result.reduce(async (acc, promise) => {
        //     /*  return acc.then(() => {
        //          return promise
        //      }).then((val) => console.log(val)).catch(err => {
        //          console.log(err);
        //      }) */
        //     try {
        //         console.log(await acc.then(() => promise))
        //     }
        //     catch (err) {
        //         console.log(err)
        //     }

        // }, Promise.resolve())


        //=============== Question =====================//

        // Design a utility which takes array of asynchronous functions and returns the 1st successful or non successful result with max waiting time set by the user

        // https://jscodechallenges.vercel.app/challenges/async#15-design-a-utility-which-takes-array-of-asynchronous-functions-and-returns-the-1st-successful-or-non-successful-result-with-max-waiting-time-set-by-the-user


        /* const asyncFunc1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('Async 1 Resolved')
            }, 6000)
        })
        const asyncFunc2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject('Async 2 Failed')
            }, 8000)
        })
        const asyncFunc3 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('Async 3 Resolved')
            }, 6000)
        });

        const asyncFunc4 = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject('Timeout !!')
            }, 5000)
        });

        const asyncFuncArr = [asyncFunc1, asyncFunc2, asyncFunc3, asyncFunc4];

        Promise.race(asyncFuncArr).then(res => console.log(res)).catch(err => console.log(err))


        const asyncFunc6 = () => {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('Async 1 Resolved')
                }, 1000)
            })
        }

        for (let i = 0; i < 5; i++) {
            console.log("i", i);
            (async function executer() {
                const result = await asyncFunc6();
                console.log("result", result)
            })()
        } */

        function requestManager(url, attempts = 3) {
            return new Promise(async (resolve, reject) => {
                for (let i = 0; i < attempts; i++) {
                    try {
                        const response = await fetch(url);
                        resolve(response);
                        break;
                    } catch (err) {
                        console.log("entered")
                        if (attempts - 1 === i) {
                            reject(err);
                            break;
                        }
                        await new Promise((resolve) => setTimeout(resolve, 1000 + 1000 * i));
                    }
                }
            });
        }

        // driver code
        requestManager("https://reqbin.com/echo/get/json", 3).then(
            (response) => console.log(response),
            (error) => console.log("error", error)
        );



    </script>
</body>

</html>